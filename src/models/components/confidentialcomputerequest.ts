/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * A request for confidential computation that includes encrypted data and associated cryptographic parameters
 */
export type ConfidentialComputeRequest = {
  /**
   * The encrypted payload that needs to be processed (base64 encoded)
   */
  ciphertext: string;
  /**
   * Client's public key for Diffie-Hellman key exchange (base64 encoded)
   */
  clientDhPublicKey: string;
  /**
   * Model name
   */
  modelName: string;
  /**
   * Node's public key for Diffie-Hellman key exchange (base64 encoded)
   */
  nodeDhPublicKey: string;
  /**
   * Cryptographic nonce used for encryption (base64 encoded)
   */
  nonce: string;
  /**
   * Number of compute units to be used for the request, for image generations,
   *
   * @remarks
   * as this value is known in advance (the number of pixels to generate)
   */
  numComputeUnits?: number | null | undefined;
  /**
   * Hash of the original plaintext body for integrity verification (base64 encoded)
   */
  plaintextBodyHash: string;
  /**
   * Salt value used in key derivation (base64 encoded)
   */
  salt: string;
  /**
   * Unique identifier for the small stack being used
   */
  stackSmallId: number;
  /**
   * Indicates whether this is a streaming request
   */
  stream?: boolean | null | undefined;
};

/** @internal */
export const ConfidentialComputeRequest$inboundSchema: z.ZodType<
  ConfidentialComputeRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  ciphertext: z.string(),
  client_dh_public_key: z.string(),
  model_name: z.string(),
  node_dh_public_key: z.string(),
  nonce: z.string(),
  num_compute_units: z.nullable(z.number().int()).optional(),
  plaintext_body_hash: z.string(),
  salt: z.string(),
  stack_small_id: z.number().int(),
  stream: z.nullable(z.boolean()).optional(),
}).transform((v) => {
  return remap$(v, {
    "client_dh_public_key": "clientDhPublicKey",
    "model_name": "modelName",
    "node_dh_public_key": "nodeDhPublicKey",
    "num_compute_units": "numComputeUnits",
    "plaintext_body_hash": "plaintextBodyHash",
    "stack_small_id": "stackSmallId",
  });
});

/** @internal */
export type ConfidentialComputeRequest$Outbound = {
  ciphertext: string;
  client_dh_public_key: string;
  model_name: string;
  node_dh_public_key: string;
  nonce: string;
  num_compute_units?: number | null | undefined;
  plaintext_body_hash: string;
  salt: string;
  stack_small_id: number;
  stream?: boolean | null | undefined;
};

/** @internal */
export const ConfidentialComputeRequest$outboundSchema: z.ZodType<
  ConfidentialComputeRequest$Outbound,
  z.ZodTypeDef,
  ConfidentialComputeRequest
> = z.object({
  ciphertext: z.string(),
  clientDhPublicKey: z.string(),
  modelName: z.string(),
  nodeDhPublicKey: z.string(),
  nonce: z.string(),
  numComputeUnits: z.nullable(z.number().int()).optional(),
  plaintextBodyHash: z.string(),
  salt: z.string(),
  stackSmallId: z.number().int(),
  stream: z.nullable(z.boolean()).optional(),
}).transform((v) => {
  return remap$(v, {
    clientDhPublicKey: "client_dh_public_key",
    modelName: "model_name",
    nodeDhPublicKey: "node_dh_public_key",
    numComputeUnits: "num_compute_units",
    plaintextBodyHash: "plaintext_body_hash",
    stackSmallId: "stack_small_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConfidentialComputeRequest$ {
  /** @deprecated use `ConfidentialComputeRequest$inboundSchema` instead. */
  export const inboundSchema = ConfidentialComputeRequest$inboundSchema;
  /** @deprecated use `ConfidentialComputeRequest$outboundSchema` instead. */
  export const outboundSchema = ConfidentialComputeRequest$outboundSchema;
  /** @deprecated use `ConfidentialComputeRequest$Outbound` instead. */
  export type Outbound = ConfidentialComputeRequest$Outbound;
}

export function confidentialComputeRequestToJSON(
  confidentialComputeRequest: ConfidentialComputeRequest,
): string {
  return JSON.stringify(
    ConfidentialComputeRequest$outboundSchema.parse(confidentialComputeRequest),
  );
}

export function confidentialComputeRequestFromJSON(
  jsonString: string,
): SafeParseResult<ConfidentialComputeRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConfidentialComputeRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConfidentialComputeRequest' from JSON`,
  );
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { confidentialEmbeddingsCreate } from "../../funcs/confidentialEmbeddingsCreate.js";
import * as components from "../../models/components/index.js";
import { formatResult, ToolDefinition } from "../tools.js";
import { decryptMessage } from "../../lib/crypto_utils.js";

const args = {
  request: components.ConfidentialComputeRequest$inboundSchema,
};

export const tool$confidentialEmbeddingsCreate: ToolDefinition<typeof args> = {
  name: "confidential-embeddings-create",
  description: `Create confidential embeddings

This endpoint follows the OpenAI API format for generating vector embeddings from input text,
but with confidential processing (through AEAD encryption and TEE hardware).
The handler receives pre-processed metadata from middleware and forwards the request to
the selected node.

## Returns
* \`Ok(Response)\` - The embeddings response from the processing node
* \`Err(AtomaProxyError)\` - An error status code if any step fails

## Errors
* \`INTERNAL_SERVER_ERROR\` - Processing or node communication failures`,
  args,
  tool: async (client, args, ctx) => {
    // Decrypt the request
    const decryptedData = decryptMessage(
      Buffer.from(args.request.ciphertext, 'base64'),
      Buffer.from(args.request.clientDhPublicKey, 'base64'),
      Buffer.from(args.request.nodeDhPublicKey, 'base64'),
      Buffer.from(args.request.salt, 'base64'),
      Buffer.from(args.request.nonce, 'base64')
    );

    if (!decryptedData) {
      return {
        content: [{ type: "text", text: "Failed to decrypt request" }],
        isError: true,
      };
    }

    const decryptedRequest = JSON.parse(new TextDecoder().decode(decryptedData));
    const result = await confidentialEmbeddingsCreate(
      client,
      decryptedRequest,
      { fetchOptions: { signal: ctx.signal } },
    );

    if (!result.ok) {
      return {
        content: [{ type: "text", text: result.error.message }],
        isError: true,
      };
    }

    const value = result.value;

    return formatResult(value, {});
  },
};
